package org.netbeans.modules.python.actions;

import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.Stack;
import javax.swing.text.BadLocationException;
import javax.swing.text.StyledDocument;
import org.openide.awt.ActionID;
import org.openide.awt.ActionReference;
import org.openide.awt.ActionRegistration;
import org.openide.cookies.EditorCookie;
import org.openide.text.NbDocument;
import org.openide.util.Exceptions;
import org.openide.util.NbBundle.Messages;

@ActionID(
        category = "Edit",
        id = "org.netbeans.modules.python.actions.FixIndentAction"
)
@ActionRegistration(
        displayName = "#CTL_FixIndentAction"
)
@ActionReference(path = "Editors/text/x-python/Popup", position = 595)
@Messages("CTL_FixIndentAction=Fix Indentation")
public final class PythonFixIndentAction implements ActionListener {

    private final EditorCookie context;

    public PythonFixIndentAction(EditorCookie context) {
        this.context = context;
    }

    @Override
    public void actionPerformed(ActionEvent ev) {
        StyledDocument doc = context.getDocument();
        int endOffset = doc.getEndPosition().getOffset();
        NbDocument.runAtomic(doc, () -> {
            try {
                String fixIndentation = fixIndentation(doc.getText(0, endOffset));
                doc.remove(0, endOffset - 1);
                doc.insertString(0, fixIndentation, null);
            } catch (BadLocationException ex) {
                Exceptions.printStackTrace(ex);
            }

        });
    }

    //Code generated by chatGPT:)
    public static String fixIndentation(String pythonCode) {
        Stack<Integer> indentStack = new Stack<>();
        String[] lines = pythonCode.split("\n");
        StringBuilder fixedCode = new StringBuilder();
        int previousIndent = 0;
        for (String line : lines) {
            int currentIndent = line.length() - line.replaceAll("^[\t ]*", "").length();
            // check if the current line has less indentation than the previous line
            if (currentIndent < previousIndent) {
                // if so, pop the indentation stack until the current indentation level is found
                while (indentStack.size() > 0 && currentIndent < indentStack.peek()) {
                    indentStack.pop();
                    //fixedCode.append("\n");
                }
            }
            // add the appropriate number of tabs or spaces to the fixed code
            for (int i = 0; i < indentStack.size(); i++) {
                fixedCode.append("    ");
            }
            // add the current line to the fixed code, with leading whitespace removed
            fixedCode.append(line.replaceAll("^[\t ]*", "") + "\n");
            // if the current line ends with a colon, add the next indentation level to the stack
            if (line.endsWith(":")) {
                indentStack.push(currentIndent + 4);
            }
            previousIndent = currentIndent;
        }
        return fixedCode.toString();
    }
}
